<?xml version="1.0" encoding="UTF-8"?><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:saxon="http://saxon.sf.net/" xmlns:map="http://www.w3.org/2005/xpath-functions/map" xmlns:array="http://www.w3.org/2005/xpath-functions/array" xmlns:fn="http://www.w3.org/2005/xpath-functions" version="3.1" xmlns:util="urn:util" exclude-result-prefixes="xs map util fn saxon">	<!-- Paraméterek -->	<xsl:param name="form-name" as="xs:string" select="''"/>	<!-- Beállítások -->	<xsl:variable name="rules-path" as="xs:string" select="concat($form-name, '_xpath.xml')"/>	<xsl:output method="xml" indent="yes"/>	<xsl:strip-space elements="*"/>	<!-- Elemtípus -->	<xsl:variable name="type-field" as="xs:string" select="'FIELD'"/>	<xsl:variable name="type-form" as="xs:string" select="'FORM'"/>	<!-- Esemény -->	<xsl:variable name="event-check" as="xs:string" select="'VALIDITY_RULE'"/>	<xsl:variable name="event-valuecalc-check" as="xs:string" select="'VALUECALC_VALIDITY_RULE'"/>		<xsl:variable name="severity-map" as="map(xs:string, xs:string)"              select="map{                    'WARNING':'1',                    'ERROR':'2',                    'CRITICAL':'3'              }"/>	<!-- Igaz: az XPath kifejezéseket egy sorba húzza (normalize-space) -->	<xsl:variable name="normalize" as="xs:boolean" select="false()"/>	<!-- Betöltjük a szabályokat -->	<xsl:variable name="elements" select="document($rules-path)/DocumentRules/Form/Elem"/>	<xsl:template name="error-writer">		<xsl:param name="errorMap" as="map(*)"/>		<Hiba kod="{$errorMap?errorCode}" hibaszoveg="{$errorMap?message}" szint="{$severity-map($errorMap?severity)}" elem="{$errorMap?fieldId}" ruleId="{$errorMap?ruleId}" path="{$errorMap?path}"/>	</xsl:template>	<xsl:template match="/">		<xsl:variable name="main-context" select="/"/>		<xsl:document>			<hibalista:Hibalista xmlns:hibalista="https://soap.api.nav.gov.hu/external/webnyk/webhibalista/1.0">				<BizonylatEllenorzes>					<Bizonylatresz formId="{$form-name}" elemindex="1">						<Azonositas>							<Munkavallalo>								<Nev>Teszt Elek</Nev>								<Adoazonosito>1234567890</Adoazonosito>							</Munkavallalo>						</Azonositas>						<Hibak>							<!-- FieldCheck-->							<xsl:iterate select="$elements[@type = $type-field]">								<xsl:variable name="fieldid" select="@name"/>								<xsl:iterate select="Rules/Rule[RuleType = $event-check]">									<xsl:param name="resultMap" as="map(xs:string, map(*))" select="map{}"/>									<!--xsl:on-completion select="$resultMap"/-->									<xsl:variable name="raw" select="Xpath"/>									<xsl:variable name="expr" select="if ($normalize) then fn:normalize-space($raw) else fn:replace($raw, '\s+$', '')"/>									<xsl:variable name="result" as="item()*">										<xsl:evaluate xpath="$expr" context-item="$main-context"/>									</xsl:variable>									<xsl:variable name="has-error" select="exists($result)"/>									<xsl:if test="$has-error">										<xsl:choose>											<!-- Egy elem kiírása -->											<xsl:when test="$has-error and $result instance of map(*)">												<xsl:variable name="key" select="normalize-space(string(map:get($result,'path')))"/>												<xsl:choose>													<!-- TODO előfordul, hogy üres a path akkor filedid-t kellene használni? Ez egy másik vetület, Olyan mintha akkor nem lenne path, ha a mező nem létezik. -->													<xsl:when test="$key eq ''">														<xsl:call-template name="error-writer">															<xsl:with-param name="errorMap" as="map(*)" select="$result"/>														</xsl:call-template>													</xsl:when>													<!-- Ha jön egy olyan hiba ami az adott path-on még nem fordult elő, akkor kiírjuk. -->													<xsl:when test="$key ne '' and not(map:contains($resultMap, $key))">														<xsl:call-template name="error-writer">															<xsl:with-param name="errorMap" as="map(*)" select="$result"/>														</xsl:call-template>													</xsl:when>												</xsl:choose>											</xsl:when>											<!-- Több elem kiírása -->											<xsl:when test="$result instance of map(*)*">												<xsl:for-each select="$result">													<xsl:variable name="resultItem" select="."/>													<xsl:variable name="key" select="normalize-space(string(map:get($resultItem,'path')))"/>													<xsl:choose>														<!-- A Nyomtatvány szintű ellenőrzések nem adnak vissza path-t. Az az elvárás, hogy azok mind fussanak le. -->														<xsl:when test="$key eq ''">															<xsl:call-template name="error-writer">																<xsl:with-param name="errorMap" as="map(*)" select="$resultItem"/>															</xsl:call-template>														</xsl:when>														<!-- Ha jön egy olyan hiba ami az adott path-on még nem fordult elő, akkor kiírjuk. -->														<xsl:when test="$key ne '' and not(map:contains($resultMap, $key))">															<xsl:call-template name="error-writer">																<xsl:with-param name="errorMap" as="map(*)" select="$resultItem"/>															</xsl:call-template>														</xsl:when>													</xsl:choose>												</xsl:for-each>											</xsl:when>											<xsl:otherwise>												<UnexpectedType>													<xsl:value-of select="serialize($result, map{'method':'adaptive'})"/>												</UnexpectedType>											</xsl:otherwise>										</xsl:choose>									</xsl:if>									<!-- path-ok kigyűjtése az iterációhoz -->									<xsl:variable name="updatedResultMap" as="map(xs:string, map(*))">										<xsl:if test="$has-error">											<xsl:choose>												<xsl:when test="$result instance of map(*)">													<xsl:variable name="key" select="normalize-space(string(map:get($result,'path')))"/>													<xsl:choose>														<!-- TODO előfordul, hogy üres a path akkor filedid-t kellene használni? Ez egy másik vetület, Olyan mintha akkor nem lenne path, ha a mező nem létezik. -->														<xsl:when test="$key eq ''">															<xsl:sequence select="$resultMap"/>														</xsl:when>														<!-- Ha jön egy olyan hiba ami az adott path-on még nem fordult elő, akkor megjegyezzük, hogy volt az adott node-ot érintő hiba. -->														<xsl:when test="$key ne '' and not(map:contains($resultMap, $key))">															<xsl:sequence select="map:put($resultMap, $key, $result)"/>														</xsl:when>														<xsl:otherwise>															<xsl:sequence select="$resultMap"/>														</xsl:otherwise>													</xsl:choose>												</xsl:when>												<xsl:when test="$result instance of map(*)*">													<!-- Megjegyeztetni az összes key-t. Bejárjuk és kivesszük az összeset -->													<xsl:variable name="pathsMap" as="map(xs:string, map(*))">														<xsl:iterate select="$result">															<xsl:param name="accu" as="map(xs:string, map(*))" select="map{}"/>															<xsl:on-completion select="$accu"/>															<xsl:variable name="p" select="normalize-space(string(map:get(., 'path')))"/>															<xsl:choose>																<xsl:when test="$p ne ''">																	<xsl:next-iteration>																		<xsl:with-param name="accu" select="map:put($accu, $p, .)"/>																	</xsl:next-iteration>																</xsl:when>																<xsl:otherwise>																	<xsl:next-iteration>																		<xsl:with-param name="accu" select="$accu"/>																	</xsl:next-iteration>																</xsl:otherwise>															</xsl:choose>														</xsl:iterate>													</xsl:variable>													<xsl:sequence select="(map:merge(($resultMap, $pathsMap), map{ 'duplicates':'use-first' })) treat as map(xs:string, map(*))"/>												</xsl:when>												<xsl:otherwise>													<xsl:sequence select="$resultMap"/>												</xsl:otherwise>											</xsl:choose>										</xsl:if>										<xsl:if test="not($has-error)">											<xsl:sequence select="$resultMap"/>										</xsl:if>									</xsl:variable>									<xsl:next-iteration>										<xsl:with-param name="resultMap" select="$updatedResultMap"/>									</xsl:next-iteration>								</xsl:iterate>							</xsl:iterate>							<!-- FormCheck-->							<xsl:iterate select="$elements[@type = $type-form]">								<xsl:variable name="fieldid" select="@name"/>								<xsl:iterate select="Rules/Rule[RuleType = $event-check]">									<xsl:variable name="raw" select="Xpath"/>									<xsl:variable name="expr" select="if ($normalize) then fn:normalize-space($raw) else fn:replace($raw, '\s+$', '')"/>									<xsl:variable name="result" as="item()*">										<xsl:evaluate xpath="$expr" context-item="$main-context"/>									</xsl:variable>									<xsl:variable name="has-error" select="exists($result)"/>									<xsl:if test="$has-error">										<xsl:choose>											<!-- Egy elem kiírása -->											<xsl:when test="$result instance of map(*)">												<xsl:call-template name="error-writer">													<xsl:with-param name="errorMap" as="map(*)" select="$result"/>												</xsl:call-template>											</xsl:when>											<!-- Több elem kiírása -->											<xsl:when test="$result instance of map(*)*">												<xsl:for-each select="$result">													<xsl:variable name="resultItem" select="."/>													<xsl:call-template name="error-writer">														<xsl:with-param name="errorMap" as="map(*)" select="$resultItem"/>													</xsl:call-template>												</xsl:for-each>											</xsl:when>											<xsl:otherwise>												<UnexpectedType>													<xsl:value-of select="serialize($result, map{'method':'adaptive'})"/>												</UnexpectedType>											</xsl:otherwise>										</xsl:choose>									</xsl:if>								</xsl:iterate>							</xsl:iterate>							<!-- CalculatedValueCheck-->							<xsl:iterate select="$elements[@type = $type-field]">								<xsl:variable name="fieldid" select="@name"/>								<xsl:iterate select="Rules/Rule[RuleType = $event-valuecalc-check]">									<xsl:variable name="raw" select="Xpath"/>									<xsl:variable name="expr" select="if ($normalize) then fn:normalize-space($raw) else fn:replace($raw, '\s+$', '')"/>									<xsl:variable name="result" as="item()*">										<xsl:evaluate xpath="$expr" context-item="$main-context"/>									</xsl:variable>									<xsl:variable name="has-error" select="exists($result)"/>									<xsl:if test="$has-error">										<xsl:choose>											<!-- Egy elem kiírása -->											<xsl:when test="$result instance of map(*)">												<xsl:call-template name="error-writer">													<xsl:with-param name="errorMap" as="map(*)" select="$result"/>												</xsl:call-template>											</xsl:when>											<!-- Több elem kiírása -->											<xsl:when test="$result instance of map(*)*">												<xsl:for-each select="$result">													<xsl:variable name="resultItem" select="."/>													<xsl:call-template name="error-writer">														<xsl:with-param name="errorMap" as="map(*)" select="$resultItem"/>													</xsl:call-template>												</xsl:for-each>											</xsl:when>											<xsl:otherwise>												<UnexpectedType>													<xsl:value-of select="serialize($result, map{'method':'adaptive'})"/>												</UnexpectedType>											</xsl:otherwise>										</xsl:choose>									</xsl:if>								</xsl:iterate>							</xsl:iterate>						</Hibak>					</Bizonylatresz>				</BizonylatEllenorzes>			</hibalista:Hibalista>		</xsl:document>	</xsl:template></xsl:stylesheet>